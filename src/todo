# Dice Module TODOs and Feature Ideas

## ‚úÖ Already implemented / covered:
- take_lowest(n), take_highest(n)
- buff(), nerf(), sum()
- roll_many(), discard_lowest()
- count_roll(value)
- Predicate-based reroll: reroll_if(Fn(u8) -> bool)
- General DicePool infrastructure (immutable, chainable)

---

## üîß Upcoming Features to Implement

### 1. Exploding Dice
- Add method to roll with exploding dice (reroll on max value).
- Consider naming: `roll_exploding()` or `roll_with_exploding()`.
- Possibly return `u32` to allow chaining.
- Bonus: allow user-defined trigger (e.g., `explode_on(value)`).

### 2. Count Successes
- Add `count_successes<F>(predicate: F) -> usize`
  - F: `Fn(u8) -> bool`
  - Example: count all rolls >= 8
- Optional helper: `count_successes_threshold(threshold: u8)`

### 3. Simple Pass/Fail Evaluation
- Add method to evaluate entire pool against a success condition.
  - Could be: `success_or_fail(Fn(&DicePool) -> bool)`
  - Or simpler: `check_total(threshold: u8) -> bool`
- Possibly return enum `Outcome { Success, Failure }` for extensibility.

### 4. Percentile Dice
- Add constructor or method: `Dice::percentile()` or `Dice::d100()`
- Optionally simulate 2d10 style (tens + ones)
- Normalize 00 ‚Üí 100 behavior

---

## ‚ùå Features deferred or out of scope (for now)
- Custom dice faces (non-numeric) ‚Äì too complex for current goals
- Push-your-luck logic ‚Äì leave to user/game logic layer

---

## üßπ Notes
- All new methods should prefer immutable return (no in-place mutation).
- Consider consistency in naming for condition/predicate-based methods.
- If functionality expands much further, consider splitting core vs. advanced tools into separate modules or traits.

